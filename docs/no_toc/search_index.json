[["index.html", "Modeling Biological Populations About this Course", " Modeling Biological Populations January, 2024 About this Course Course Materials for MBP 2024. "],["syllabus.html", "Chapter 1 Syllabus", " Chapter 1 Syllabus Course Number: AS.020.313 Schedule: Intersession 2024, Tues, Thurs 01:00 PM - 05:00 PM Location Homewood Campus, UG Teaching Lab (UTL) 189 Office Hours: Tues, Thurs 12:00 PM - 1:00 PM, or by appointment; UTL 189 Instructors: Andrew Bortvin Dylan Taylor Course Description Population biologists study the dynamics of how populations behave and change, but these processes are often too complex for direct observation. Computational tools are therefore essential to the study of biological populations, as they allow for study across time scales far beyond what can be observed. Students will be introduced to computational biology, using the fundamentals of coding in the Python programming language. We will apply this code in developing simulations of biological populations, including invasive species and cancerous tumors. Students will enact and observe the effects of various parameters (e.g., mutation, environmental pressure, behavior, random chance) on their populations. We will also explore how these models can be applied in other fields, and how biology makes use of models from fields including linguistics and economics. Upon completing the course, students will be prepared to independently continue learning more advanced programming concepts. Prior programming experience is not required. Students from all departments and at all levels (including first-year undergraduates) are welcome. Class Structure Class Organization Each class will be divided between lectures covering biological principles, live coding where we teach programming in Python, and in-class completion of assignments. For live coding, we will offer two sections, one of which focuses more on coding fundamentals and syntax, and one which moves at a faster pace and covers more biological implementation for students comfortable with programming. As this is a longer class, we will take breaks between sections. Feel free to bring snacks or drinks. Assignments Each day, we will reserve time to work on in-class assignments, which will primarily focus on implementation of population models in Python and conceptual questions regarding the theory behind population biology. Each assignment will consist of a series of basic and advanced exercises. We expect all students to complete the basic exercises, which will focus on the models we explicitly discuss in class. Advanced exercises are optional and will allow students to extend the models we cover in class. We encourage all students to try advanced exercises, as they will contain many of the most exciting biological concepts that we will cover. For this course, we will be using Google Colab both for live coding during class as well as completing exercises/assignments during and after class. To submit assignments, you can email the instructors a link to your notebook. If you have previous coding experience and are more comfortable using a local Python installation, feel free to do so. If you run Python locally, please submit a copy of your scripts along with all output and text files with written answers, when appropriate. You are welcome to work together in small groups, and collaboration is encouraged. Likewise, we encourage you to seek answers online when encountering. However, please refrain from just copying someone else’s code – you should understand and be able to explain every line of code in your scripts. Schedule Class Number Date Topics Covered 1 1/2/24 Population Growth Models: Exponential and Logistic Growth 2 1/4/24 Two Population Models: Mutualism, Competition, Predator/Prey Dynamics 3 1/9/24 Population Genetics: The Basic Wright-Fisher Model and Biological Simulations 4 1/11/24 Population Genetics: Wright-Fisher with Modification 5 1/16/24 Independent Work: Develop Your Own Models 6 1/18/24 Independent Work: Develop Your Own Models (Part II); Models from Other Fields Grading This course will be graded Satisfactory/Unsatisfactory, and individual assignments will be graded on reasonable completion (rather than accuracy of results). In each assignment, we will specify items to include in your submission; the assignment score will be the fraction of items completed. To achieve a Satisfactory, you must have an average of 70% completion across the assignments. All assignments will be due at the end of the course period (1/18/24). However, please submit your work at the end of the day - we will look at your work in progress, provide written feedback, discuss any questions or opoprtunities for improvement, and let you know estimated percent completion. Office Hours We will host office hours every day prior to the start of class (12:00 PM - 1:00 PM) in our classroom, UTL 189. If this time does not work for you, please reach out to us and we can find alternative times for individual meetings. "],["python-guide.html", "Chapter 2 Python Guide", " Chapter 2 Python Guide "],["data-types.html", "2.1 Data Types", " 2.1 Data Types Integers are whole numbers. For example: 2 -3 0 Floats are numbers with a decimal point. For example: 1.2 -3.0 26/3 (evaluates to 8.666) Strings are characters enclosed by single ' or double \" quotation marks. Any text enclosed by quotes will be treated as a string. \"My Grandpa's deck has no pathetic cards\" '85.3' Note the second example – 85.3 is a float; '85.3' is a string. Booleans have two possible values: True and False. These can also be expressed as 1 (true) or 0 (false). We can use the type() function to figure out the data type of an object. "],["variables.html", "2.2 Variables", " 2.2 Variables Variables are assigned using the = sign: variable_name = value For example: composer = \"buxtehude\" year = 1637 The variable name can be almost anything. Here are some general rules to consider when naming a variable: The name must start with a letter or underscore The name can only consist of letters, numbers, or underscores Variables are case sensitive (i.e. Python interprets my_number, MY_NUMBER, and My_Number as different variables) Python has a set of “reserved words” that cannot be used as variable names. These are words that already have a set meaning in Python, such as True, False, for, and if. A full list can be found here. "],["math.html", "2.3 Math", " 2.3 Math 2.3.1 Mathematical operations A lot of mathematical operations in Python are straightforward. Here are some of the basic operations we can perform: + and -: addition and subtraction * and /: multiplication and division **: exponentials We can perform mathematical operations on values directly: print(2 + 3) ## 5 Or we can operate on variables: myValue = 4 print(myValue**2) ## 16 Python will automatically convert integers to floats when appropriate: print(3 + 2.2) ## 5.2 We can save the output of an expression as a variable: my_product = 2 * 10 print(my_product) ## 20 And likewise we can perform mathematical operations on variables, if these variables store numeric data: number1 = 7 print(number1 / 2) ## 3.5 2.3.2 Order of operations Python follows the usual mathematical order of operations. And like in math, we can use parentheses () to enforce a specific order. print(2 * (2 + 2)) ## 8 "],["lists.html", "2.4 Lists", " 2.4 Lists Lists allow us to store multiple objects together. A list is a sequential group of variables, denoted in Python by square brackets [], with individual entries separated by commas. A few of the neat properties of lists are: Ordered: The list [1, 5, 3, 7] will always store those numbers in the same order. Mixed data types: [\"mercury\", 13, 5.3, False] is a valid list which contains every data type we’ve seen so far. Can contain other lists: [[2, 3], \"sulfur\", 12, 18] Can contain repeat values: [\"tomato\", \"tomato\", \"tomato\", \"sulfur\"] 2.4.1 Indexing What if we want to extract a specific value from a list? We can use indexing. To index in Python, we use the following syntax: variable_name[index] where index is the number of the item we wish to extract. alchemists = [&quot;Zosimos&quot;, &quot;Oresme&quot;, &quot;Flamel&quot;, &quot;pseudo-Aristotle&quot;] print(alchemists[1]) ## Oresme Notice that when we printed the item at position 1, we printed out the second entry in alchemists. This is because in Python, indexing begins at 0. To print out the first entry, we would use alchemists[0]. A couple interesting things we can do with indexing: To print multiple consecutive items, we can provide two numbers separated by a colon :. print(alchemists[0:2]) ## [&#39;Zosimos&#39;, &#39;Oresme&#39;] Note that the first number is inclusive and the second number is exclusive: we include the item at position 0 ('Zosimos'), but not the item at position 2 ('Flamel'). We can index in reverse. To index from the end of a list, we use negative numbers. print(alchemists[-1]) ## pseudo-Aristotle Nested lists How would we extract the number 3 from the list below? my_list = [1, 2, [3, 4], 5] First, we extract the [3, 4] list. This is the third item of the outer list, so it is at position 2 (remember, indexing in Python starts at 0). So we can access the interior list with my_list[2]: print(my_list[2]) ## [3, 4] Within the interior list, 3 is the first item, so it is at position 0. It can be accessed with the syntax my_list[2][0]: print(my_list[2][0]) ## 3 2.4.1.1 Indexing Strings We can also apply indexing to extract substrings from within a string. This is done identically to how we index a list: creature = &#39;stingray&#39; print(creature[0:5]) ## sting 2.4.2 Adding to lists Finally, we can add entries to the end of a list. We do this with the append() method, which is used with the following syntax: list_name.append(item) For example: florilegium = [&#39;marigold&#39;, &#39;thistle&#39;, &#39;wormwood&#39;] florilegium.append(&#39;tansy&#39;) print(florilegium) ## [&#39;marigold&#39;, &#39;thistle&#39;, &#39;wormwood&#39;, &#39;tansy&#39;] "],["for-loops.html", "2.5 For Loops", " 2.5 For Loops In Python, we will often want to perform an action more than once. For example, if we have a list, we might want to do the same operatation on every item within the list. One way to do this is to use a for loop, which is structured like this: for &lt;temporary_variable&gt; in &lt;thing to loop through&gt;: {do something} For example: stations = [&quot;Oddity&quot;, &quot;Londres&quot;, &quot;Cherry&quot;, &quot;Swedish&quot;] for i in stations: print(i) ## Oddity ## Londres ## Cherry ## Swedish 2.5.1 For loop walkthrough Here is how the loop works: for i in stations: In this line, we: Define the temporary variable i. The name of this variable is arbitrary. We say that we are looping through stations. In the first iteration of the for loop, i takes on the value of the first item in stations (\"Oddity\"). Now we perform all of the indented code, which here is just a print() statement. In the second iteration of the for loop, we set the value of i to the second entry in stations (\"Londres\"). We execute all of the indented code, printing out \"Londres\". We continue on doing this until there is nothing left in stations. In this example, there was a single line in the body of the loop, but a for loop can be arbitrarily long. Here is a longer example: my_list = [1, 4, 6, 9, 10, 2] for i in my_list: i = i + 3 i = i ** 2 print(i) ## 16 ## 49 ## 81 ## 144 ## 169 ## 25 2.5.2 Repeating an action n times We can also use a for loop to perform an action a set number of times, even when we don’t have a list to loop through. To do so, we can use the range() function. We’ll use this function a ton throughout the course. range(&lt;n&gt;), where n is a single integer, generates a sequence of numbers from 0 to n (not including n itself). So to run a function 3 times, we would provide the for loop with range(3) (which generates the list [0, 1, 2]). for i in range(3): print(i) ## 0 ## 1 ## 2 So far, the body of our for loop has always referenced the temporary variable i. We can also use a for loop to run a block of code repeatedly without actually manipulating i: for i in range(3): print(&quot;All work and no play&quot;) ## All work and no play ## All work and no play ## All work and no play "],["modules.html", "2.6 Modules", " 2.6 Modules Often, we need to make use of functions beyond the basic ones in Python. To do this, we can import a module, or a collection of pre-written functions. A module is imported with the following syntax: import &lt;module name&gt; For example, to import the popular plotting module Matplotlib, we write: import matplotlib.pyplot 2.6.1 Module functions To use a function from Matplotlib, we need to reference both the package name and the function name, with the general syntax: moduleName.functionName() To use Matplotlib’s show() function, we would write: matplotlib.pyplot.show() 2.6.2 Abbreviating module names What if you don’t want to write out matplotlib.pyplot every time you run a Matplotlib function? To simplify this, we can give our modules a shorthand name. For example: import matplotlib.pyplot as plt Now, instead of writing out matplotlib.pyplot, we can just write plt. The previous matplotlib.pyplot.show() command is shortened to: plt.show() "],["plotting-with-matplotlib.html", "2.7 Plotting with matplotlib", " 2.7 Plotting with matplotlib In this course, we will use the library Matplotlib for plotting. For concision, we will import the matplotlib.pyplot module with the name plt, as such: import matplotlib.pyplot as plt 2.7.1 Line and Scatter Plots - Walkthrough We can initialize a figure with the following line: fig, ax = plt.subplots() This initializes a figure (named fig) and a plot within the figure (named ax). Having separate variables for the figure and the plot within the figure may seem strange, but it will make it considerably easier to arrange and manipulate multiple subplots within a larger figure. At present, our figure is just an empty canvas: 2.7.1.1 Points and Lines Let’s add to our subplot by plotting some data. I’ve stored the temperature in Fahrenheit in Baltimore, MD and Wommels, Netherlands for the next seven hours: hours = range(7) tempBaltimore = [74, 73, 72, 71, 75, 79, 87] tempWommels = [59, 60, 62, 65, 69, 72, 67] To plot a set of points, we can use the .scatter() method This function takes two mandatory arguments: a list of x coordinates and a list of y coordinates. We can plot the temperature in Baltimore as such: ax.scatter(hours, tempBaltimore) We can display our plot by running the function plt.show(). Our plot will look like this: Note that the .scatter() method has a variety of optional arguments that can be used to configure the appearance of your points; we will often modify the color (c), size (s), and shape (m) of our points. A full list of options can be found here. To add a line, we use the .plot() method. Like .scatter(), this function takes as arguments lists of x and y positions, and allows for aesthetic customization with a variety of optional parameters. For more information on these options, look here. Our plotting code now looks like this: import matplotlib.pyplot as plt hours = range(7) tempBaltimore = [74, 73, 72, 71, 75, 79, 87] tempWommels = [59, 60, 62, 65, 69, 72, 67] fig, ax = plt.subplots() ax.scatter(hours, tempBaltimore) ax.plot(hours, tempBaltimore) plt.show() and generates this image: 2.7.1.2 Multiple Sets of Data To plot both Baltimore and Wommels, we simply add a second call to .scatter() and .plot(): fig, ax = plt.subplots() ax.scatter(hours, tempBaltimore) ax.plot(hours, tempBaltimore) ax.scatter(hours, tempWommels) ax.plot(hours, tempWommels) plt.show() A couple things are interesting about this plot: The y axis scale adjust automatically to fit in Wommels. The second time that we call the .scatter() and .plot() functions, they automatically plot in a new color. If we were to add a third set of points, they would again be in a new color. 2.7.1.3 Labels and Legends To an observe, our plot is a bit confusing because it is unclear which line represents Wommels and which line represents Baltimore. We could clarify this by adding a legend. There are two steps to doing this: We need to use the optional label argument. This argument tells the interpreter how to label a line or set of points in the legend. For example, we can label a set of points as such: ax.scatter(hours, tempBaltimore, label='Baltimore'). In this example, we can label either the scatter plots or the line plots. Create a legend using the .legend() method. fig, ax = plt.subplots() ax.scatter(hours, tempBaltimore, label=&#39;Baltimore&#39;) ax.plot(hours, tempBaltimore) ax.scatter(hours, tempWommels, label=&#39;Wommels&#39;) ax.plot(hours, tempWommels) ax.legend() plt.show() 2.7.1.4 Figure Aesthetics Now that our data is plotted, let’s add some axis labels using the .set_xlabel() and .set_ylabel() methods: ax.set_xlabel(&quot;Time (Hours)&quot;) ax.set_ylabel(&quot;Temperature (F)&quot;) We can set a title as such: ax.set_title(&#39;Temperature in Baltimore and Wommels&#39;) If we wanted to set custom limits for our x and y limits, we can use the set_xlim() and set_ylim() methods: ax.set_ylim(50, 100) Altogether, our final image looks like this: 2.7.2 Histograms Histograms are a convenient way of visually displaying the overall distribution of a one-dimensional dataset. I’ve found 25 towns worldwide named Baltimore. Here are their current temperature in Fahrenheit saved to a list: temperatureBaltimore = [69, 83, 82, 90, 77, 89, 82, 67, 59, 86, 74, 77, 58, 67, 62, 91, 73, 81, 67, 87, 61, 67, 61, 108, 112] To generate a histogram, we use the .hist() method. By default, this method takes just one argument: the data that you wish to plot. fig, ax = plt.subplots() ax.hist(temperatureBaltimore) ax.set_xlabel(&#39;Temperature (F)&#39;) ax.set_ylabel(&#39;Frequency&#39;) ax.set_title(&#39;Current Temperature in Every Town Named Baltimore&#39;) plt.show() One important argument for the .hist() method is bins, which allows us to set how many groups our data is divided into. The more bins there are, the fewer x values will be contained within a single bin. For example, plotting the Baltimore data with a larger number of bins: ax.hist(temperatureBaltimore, bins = 20) "],["class-notebooks-and-slides.html", "Chapter 3 Class Notebooks and Slides", " Chapter 3 Class Notebooks and Slides This page will host links to all slides and Google Colab notebooks used in class. Day 1: Exponential and Logistic Growth Class Slides: Colab Notebooks: Blank Notebook "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
